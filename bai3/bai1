% huffman_lab_full.m
% Huffman coding demo + v? cây Huffman
% Ch?y b?ng: >> huffman_demo

function huffman_demo()
fprintf('--- Huffman coding demo ---\n');

% ====== 1) Khai báo k? hi?u và xác su?t ======
symbols = {'A','B','C','D','E','F'};
p       = [0.32, 0.18, 0.15, 0.14, 0.12, 0.09]; % t?ng ~1

% ====== 2) Xây cây Huffman và gán m? ======
tree = huffman_build(symbols, p);
codes = assign_codes(tree);

fprintf('\nSymbol -> Code\n');
for i = 1:length(symbols)
    fprintf(' %s -> %s\n', symbols{i}, codes{i});
end

% ====== 3) V? cây Huffman ======
plot_huffman_tree(tree, symbols, codes);

% ====== 4) M? hóa m?t chu?i k? hi?u ======
sample_seq = {'A','B','A','C','F','E','A','D','B','C'};
bitstream = huffman_encode(sample_seq, symbols, codes);
fprintf('\nSample sequence: '); disp(sample_seq);
fprintf('Encoded bitstream: %s\n', bitstream);

% ====== 5) Gi?i m? ======
decoded_seq = huffman_decode(bitstream, tree, symbols);
fprintf('Decoded sequence: '); disp(decoded_seq);

if isequal(sample_seq, decoded_seq)
    fprintf('Decoding OK: recovered sequence equals original.\n');
else
    warning('Decoded sequence differs from original!');
end

% ====== 6) Entropy và ?? dài trung b?nh ======
H = entropy_from_prob(p);
L_avg = 0;
for i = 1:length(p)
    L_avg = L_avg + p(i) * length(codes{i});
end
fprintf('\nEntropy H(X) = %.4f bits/symbol\n', H);
fprintf('Average code length L = %.4f bits/symbol\n', L_avg);
fprintf('Redundancy L - H = %.4f bits/symbol\n', L_avg - H);

end

%% --------------------- Hàm xây Huffman tree ---------------------
function tree = huffman_build(symbols, prob)
m = numel(symbols);
if numel(prob) ~= m, error('symbols và prob ph?i cùng kích th??c'); end
if abs(sum(prob)-1)>1e-6, prob = prob/sum(prob); end

nodes = struct('weight', {}, 'symbol', {}, 'left', {}, 'right', {});
for i = 1:m
    nodes(i).weight = prob(i);
    nodes(i).symbol = i;
    nodes(i).left = [];
    nodes(i).right = [];
end

alive = 1:m;
while numel(alive) > 1
    weights = arrayfun(@(i) nodes(i).weight, alive);
    [~, sidx] = sort(weights);
    i1 = alive(sidx(1)); i2 = alive(sidx(2));
    newnode.weight = nodes(i1).weight + nodes(i2).weight;
    newnode.symbol = [];
    newnode.left = i1; newnode.right = i2;
    nodes(end+1) = newnode;
    pos = sort(sidx(1:2), 'descend'); alive(pos(1))=[]; alive(pos(2))=[];
    alive(end+1) = numel(nodes);
end
tree = nodes;
end

%% --------------------- Gán m? Huffman ---------------------
function codes = assign_codes(tree)
n_nodes = numel(tree);
leaf_mask = arrayfun(@(x) ~isempty(x.symbol), tree);
leaf_indices = find(leaf_mask);
m = max([tree(leaf_indices).symbol]);
codes = cell(1,m);

root = n_nodes;
if n_nodes==1, codes{tree(1).symbol}='0'; return; end

stack = struct('node', {}, 'code', {});
stack(1).node=root; stack(1).code='';

while ~isempty(stack)
    entry = stack(end); stack(end)=[];
    node_idx = entry.node; cur_code = entry.code;
    node = tree(node_idx);
    if ~isempty(node.symbol)
        codes{node.symbol} = cur_code;
    else
        if ~isempty(node.right), stack(end+1).node=node.right; stack(end).code=[cur_code '1']; end
        if ~isempty(node.left),  stack(end+1).node=node.left;  stack(end).code=[cur_code '0']; end
    end
end
end

%% --------------------- M? hóa ---------------------
function bitstream = huffman_encode(seq, symbols, codes)
if ischar(seq), seq = cellstr(num2cell(seq')'); end
m = length(symbols);
map = containers.Map;
for i=1:m, map(char(symbols{i}))=i; end
bitstream = '';
for k=1:length(seq)
    key = char(seq{k});
    idx = map(key);
    bitstream = [bitstream codes{idx}]; %#ok<AGROW>
end
end

%% --------------------- Gi?i m? ---------------------
function decoded_seq = huffman_decode(bitstream, tree, symbols)
if isempty(bitstream), decoded_seq={}; return; end
root = numel(tree); cur_node=root; decoded_seq={};
for i=1:length(bitstream)
    b = bitstream(i);
    if b=='0', next_node = tree(cur_node).left;
    elseif b=='1', next_node = tree(cur_node).right;
    else error('Invalid bit'); end
    cur_node = next_node;
    if ~isempty(tree(cur_node).symbol)
        decoded_seq{end+1} = symbols{tree(cur_node).symbol}; %#ok<AGROW>
        cur_node=root;
    end
end
end

%% --------------------- Entropy ---------------------
function H = entropy_from_prob(p)
p = p(:); p(p<=0)=[]; H = -sum(p.*log2(p));
end

%% --------------------- V? cây Huffman ---------------------
function plot_huffman_tree(tree, symbols, codes)
root = numel(tree);
figure('Name','Huffman Tree','Color','w'); axis off; hold on;
plot_node(tree, root, symbols, codes, 0, 0, 2);
end

function plot_node(tree, idx, symbols, codes, x, y, spacing)
node = tree(idx);
if ~isempty(node.symbol)
    lbl = sprintf('%s\n%s', symbols{node.symbol}, codes{node.symbol});
else
    lbl = sprintf('%.2f', node.weight);
end
text(x, y, lbl, 'HorizontalAlignment','center', ...
    'VerticalAlignment','middle', 'BackgroundColor','w', 'Margin',1, 'FontSize',10);

dx = spacing/2;
if ~isempty(node.left)
    x_left = x-dx; y_child=y-1;
    plot([x x_left],[y y_child],'k-','LineWidth',1);
    plot_node(tree,node.left,symbols,codes,x_left,y_child,dx);
end
if ~isempty(node.right)
    x_right=x+dx; y_child=y-1;
    plot([x x_right],[y y_child],'k-','LineWidth',1);
    plot_node(tree,node.right,symbols,codes,x_right,y_child,dx);
end
end
